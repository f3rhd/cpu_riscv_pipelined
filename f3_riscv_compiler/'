#include "nodes.hpp"
#include <algorithm>


// AST printing
auto constexpr COLOR_RESET = "\033[0m";
auto constexpr COLOR_FUNC = "\033[36m"; // cyan
auto constexpr COLOR_VAR = "\033[35m"; // magenta
auto constexpr COLOR_TYPE = "\033[32m"; // green
auto constexpr COLOR_LIT = "\033[33m"; // yellow
auto constexpr COLOR_OP = "\033[31m";  // red;
auto constexpr COLOR_LABEL = "\033[90m"; // gray
using namespace f3_compiler::ast_node;
using namespace f3_compiler;
namespace {

	inline int32_t align_up(int32_t offset, int32_t alignment) {
		return (offset + alignment - 1) / alignment * alignment;
	}
	inline int32_t actual_offset(int32_t total_frame_size, int32_t logical_offset, int32_t saved_regs_bytes = 8) {
		return (saved_regs_bytes + logical_offset);
	}
}
static inline std::string bin_op_to_string(f3_compiler::ast_node::BIN_OP op) {
	switch (op) {
	case BIN_OP::ADD: return "+";
	case BIN_OP::SUB: return "-";
	case BIN_OP::DIV: return "/";
	case BIN_OP::MUL: return "*";
	case BIN_OP::MOD: return "%";
	case BIN_OP::GT: return ">";
	case BIN_OP::LT: return "<";
	case BIN_OP::GTE: return ">=";
	case BIN_OP::LTE: return "<=";
	case BIN_OP::EQUALITY: return "==";
	case BIN_OP::NOT_EQUAL: return "!=";
	case BIN_OP::AND: return "&&";
	case BIN_OP::OR: return "||";
	}
	return "????";
}

static inline std::string unary_op_to_string(f3_compiler::ast_node::UNARY_OP op) {
	switch (op)
	{
	case UNARY_OP::NEG:
		return "-";
	case UNARY_OP::INCR:
		return "++";
	case UNARY_OP::DECR:
		return "--";
	case UNARY_OP::NOT:
		return "!";
	case UNARY_OP::ADDR:
		return "&";
	case UNARY_OP::DEREF:
		return "*";
	default:
		return "????";
	}

}
static void draw_branch(std::ostream& os, uint32_t indent_level, bool is_last) {
	for (uint32_t i = 0; i < indent_level; i++)
		os << "    ";
	os << (is_last ? "'-- " : "|--");
}


// @call : expressions
// @return : offset of the variable or register that holds the variable's value or register that holds the variable's value
code_gen::generation_info_t var_expression_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const
{
	if (HAS_FLAG(flags, code_gen::flags::FOR_RANGE_PHASE_1)) {
		return {};
	}
	code_gen::var_info_t var_info = ctx.get_var_info(name);
	if (var_info.type.pointer_depth > 0) { //@Uncomplete : probably for type checking

	}

	if(HAS_FLAG(flags,code_gen::flags::ALLOCATE_VAR_IN_REG)){
		std::string allocated_register;
		if (ctx.try_allocate_register_for_var(name, allocated_register)) {

			os << "\tlw " << allocated_register << "," << actual_offset(ctx.frame_size,var_info.offset) << "(s0)\n";
			return { "",name,std::move(allocated_register)};
		}
		return {}; // @LacksError
	}
	return { std::to_string(actual_offset(ctx.frame_size,var_info.offset)),name,""};

}

code_gen::generation_info_t func_decl_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx,int32_t flags) const
{
	std::ostringstream prologue;
	auto frame_size = align_up(ctx.offset_counter, 16);
	ctx.frame_size = frame_size;

	prologue << id << ":\n";
	prologue << "\taddi sp,sp," << -frame_size << '\n';
	prologue << "\tsw ra," << frame_size - 4 << "(sp)\n";
	prologue << "\tsw s0," << frame_size - 8 << "(sp)\n";
	prologue << "\taddi s0,sp," << frame_size << '\n'; // frame pointer
	os << prologue.str();
	auto func_info = ctx.get_func_decl_info(id);
	for (uint32_t i = 0; i < func_info.parameters.size();i++) {
		os << "\tsw " << "a" << std::to_string(i) <<',' << actual_offset(ctx.frame_size, func_info.parameters[i].offset) << "(s0)\n";
	}
	// generate body instructions
	body->generate_code(os, ctx);

	// epilogue
	std::ostringstream epilogue;
	if (!ctx.return_jump_labels.empty()) {
		os << ctx.return_jump_labels.back() << ":\n";
	}
	epilogue << "\tlw ra," << frame_size - 4 << "(sp)\n";
	epilogue << "\tlw s0," << frame_size - 8 << "(sp)\n";
	epilogue << "\taddi sp,sp," << frame_size << '\n';
	epilogue << "\tjr ra\n";
	os << epilogue.str();
	return {};
}

code_gen::generation_info_t integer_literal_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const
{
	if(value == 0){
		return {"","int","zero"};
	}
	std::ostringstream load_instr;
	std::string allocated_register = ctx.allocate_register();
	load_instr << "\tli " << allocated_register << ',' << value << '\n';
	os << load_instr.str();
	return {"","int",std::move(allocated_register)};
}


code_gen::generation_info_t func_call_expr_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const //@Incomplete : No semantic analysis
{
	std::vector<std::string> regs;
	for (int32_t i = 0; i < arguments.size(); i++) {
		code_gen::generation_info_t gen_info = arguments[i]->generate_code(os, ctx, code_gen::flags::ALLOCATE_VAR_IN_REG);
		os << "\tmv a" << i << ", " << gen_info.allocated_reg << "\n";
		ctx.update_register_for_var(gen_info.var_name, gen_info.allocated_reg);
	}
	os << "\tcall " << id << "\n";
	return "a0";
}

//@call : general expressions
// @return : destination register 
std::string binary_expression_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const
{

	std::string operand_1 = lhs->generate_code(os, ctx,code_gen::flags::ALLOCATE_VAR_IN_REG);
	std::string operand_2 = rhs->generate_code(os, ctx,code_gen::flags::ALLOCATE_VAR_IN_REG);
	std::string destination_register;
	// x > 0
	os << '\t';
	switch (op) {
	case BIN_OP::GT:
		if (HAS_FLAG(flags,code_gen::flags::WHILE_CONTROL_KEYWORD)) {
			os << "bgt";

		}
		else if (HAS_FLAG(flags, code_gen::flags::IF_CONDITIONAL_EXPR)) {
			os << "blt";
		}
		os << " " << operand_1 << "," << operand_2;
		ctx.free_register(operand_1);
		ctx.free_register(operand_2);
		return "";
	case BIN_OP::LT:
		if (HAS_FLAG(flags,code_gen::flags::WHILE_CONTROL_KEYWORD)) {
			os << "blt";

		}
		else if (HAS_FLAG(flags, code_gen::flags::IF_CONDITIONAL_EXPR)) {
			os << "bgt";
		}
		os << " " << operand_1 << "," << operand_2;
		ctx.free_register(operand_1);
		ctx.free_register(operand_2);
		return "";
	case BIN_OP::GTE:
		if (HAS_FLAG(flags,code_gen::flags::WHILE_CONTROL_KEYWORD)) {
			os << "bge";

		}
		else if (HAS_FLAG(flags, code_gen::flags::IF_CONDITIONAL_EXPR)) {
			os << "ble";
		}
		os << " " << operand_1 << "," << operand_2;
		ctx.free_register(operand_1);
		ctx.free_register(operand_2);
		return "";
	case BIN_OP::LTE:
		if (HAS_FLAG(flags,code_gen::flags::WHILE_CONTROL_KEYWORD)) {
			os << "ble";

		}
		else if (HAS_FLAG(flags, code_gen::flags::IF_CONDITIONAL_EXPR)) {
			os << "bgt";
		}
		os << " " << operand_1 << "," << operand_2;
		ctx.free_register(operand_1);
		ctx.free_register(operand_2);
		return "";
	case BIN_OP::EQUALITY:
		if (HAS_FLAG(flags,code_gen::flags::WHILE_CONTROL_KEYWORD)) {
			os << "beq";

		}
		else if (HAS_FLAG(flags, code_gen::flags::IF_CONDITIONAL_EXPR)) {
			os << "bneq";
		}
		os << " " << operand_1 << "," << operand_2;
		ctx.free_register(operand_1);
		ctx.free_register(operand_2);
		return "";
	case BIN_OP::NOT_EQUAL:
		if (HAS_FLAG(flags,code_gen::flags::WHILE_CONTROL_KEYWORD)) {
			os << "bneq";

		}
		else if (HAS_FLAG(flags, code_gen::flags::IF_CONDITIONAL_EXPR)) {
			os << "beq";
		}
		os << " " << operand_1 << "," << operand_2;
		ctx.free_register(operand_1);
		ctx.free_register(operand_2);
		return "";
	case BIN_OP::ADD:
		destination_register = ctx.allocate_register();
		os << "add";
		break;
	case BIN_OP::SUB:
		destination_register = ctx.allocate_register();
		os << "sub";
		break;
	case BIN_OP::DIV:
		destination_register = ctx.allocate_register();
		os << "div";
		break;
	case BIN_OP::MUL:
		destination_register = ctx.allocate_register();
		os << "mul";
		break;
	case BIN_OP::MOD:
		destination_register = ctx.allocate_register();
		os << "rem";
		break;
	case BIN_OP::AND:
		destination_register = ctx.allocate_register();
		os << "and";
		break;
	case BIN_OP::OR:
		destination_register = ctx.allocate_register();
		os << "or";
		break;
	default:
		break;

	}
	os << ' ' << destination_register << "," << operand_1 << "," << operand_2 << '\n';
	ctx.free_register(operand_1);
	ctx.free_register(operand_2);
	return destination_register;
}


std::string unary_expression_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx,int32_t flags) const
{

	std::string destination_register = ctx.allocate_register();
	std::string source_register ;
	std::string offset;
	switch (op) {
	case UNARY_OP::NEG:
		// x = -y + 3;
		source_register = expr->generate_code(os, ctx, code_gen::flags::ALLOCATE_VAR_IN_REG);
		if (HAS_FLAG(flags,code_gen::flags::ALLOCATE_VAR_IN_REG)) {
			os << '\t' << "neg " << destination_register << ',' << source_register << '\n';
		}
		break;
	case UNARY_OP::INCR:
		source_register = expr->generate_code(os, ctx, code_gen::flags::ALLOCATE_VAR_IN_REG);
		ctx.free_register(destination_register);
		destination_register = source_register;
		os << '\t' << "addi " << destination_register << ',' << source_register << ",1" << '\n';
		offset = expr->generate_code(os, ctx);
		os << "\t" << "sw " << source_register << "," << offset << "(s0)\n";
		break;
	case UNARY_OP::DECR:
		source_register = expr->generate_code(os, ctx, code_gen::flags::ALLOCATE_VAR_IN_REG);
		ctx.free_register(destination_register);
		destination_register = source_register;
		os << '\t' << "addi " << destination_register << ',' << source_register << ",-1" << '\n';
		offset = expr->generate_code(os, ctx);
		os << "\t" << "sw " << source_register << "," << offset << "(s0)\n";
		break;
		break;
	case UNARY_OP::NOT:
		break;
	case UNARY_OP::ADDR:
		os << '\t' << "addi " << destination_register << ',' << "s0," << expr->generate_code(os, ctx) << "\n";
		break;
	case UNARY_OP::DEREF:
		if (HAS_FLAG(flags,code_gen::flags::ALLOCATE_VAR_IN_REG)) {
			os << '\t' << "lw " << destination_register << ',' << expr->generate_code(os, ctx) << "(s0)" << "\n";
			os << '\t' << "lw " << destination_register << ',' << "0(" << destination_register << ")" << "\n";
		}
		else {
			source_register = expr->generate_code(os, ctx, code_gen::flags::ALLOCATE_VAR_IN_REG);
			os << '\t' << "mv " << destination_register << ',' << source_register << '\n';
		}
		break;
	default:
		break;

	}
	ctx.free_register(source_register);
	return destination_register;
}

std::string for_range_expression_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const
{

	// for(x...=123)
	// if there is assingment in the left handside
	if (HAS_FLAG(flags, code_gen::flags::FOR_RANGE_PHASE_1)) {
		return start->generate_code(os, ctx,code_gen::flags::FOR_RANGE_PHASE_1);
	}
	if (HAS_FLAG(flags, code_gen::flags::FOR_RANGE_PHASE_2)) {
		return start->generate_code(os, ctx, code_gen::flags::ALLOCATE_VAR_IN_REG);
	}
	std::string reg = destination->generate_code(os, ctx, code_gen::flags::ALLOCATE_VAR_IN_REG);
	if (is_exclusive) {
		os << "\taddi " << reg << "," << reg << ",-1\n";
	}
	return reg;
}
std::string for_statement_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const
{

	range->generate_code(os, ctx, code_gen::flags::FOR_RANGE_PHASE_1);
	std::string label1 = ctx.create_label();
	std::string label2 = ctx.create_label();
	os << "\tj " << label1 << "\n";
	os << label2 << ":\n";
	body->generate_code(os, ctx,code_gen::flags::FOR_CONTROL_KEYWORD);
	if (!ctx.skip_jump_labels.empty()) {
		os << ctx.skip_jump_labels.back() << ":\n";
		ctx.skip_jump_labels.pop_back();
	}
	step->generate_code(os, ctx);
	os << label1 << ":\n";
	std::string iterator = range->generate_code(os, ctx, code_gen::flags::FOR_RANGE_PHASE_2);
	std::string destination = range->generate_code(os, ctx, code_gen::flags::FOR_RANGE_PHASE_3);
	os << "\tble " << iterator << "," << destination << "," << label2 << "\n";
	if (!ctx.break_jump_labels.empty()) {
		os << ctx.break_jump_labels.back() << ":\n";
		ctx.break_jump_labels.pop_back();
	}
	if (!iterator.empty()) {
		ctx.free_register(iterator);
	}
	if (!destination.empty()) {
		ctx.free_register(destination);
	}
	return "";
}


std::string assignment_expression_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx,int32_t flags) const
{

	// *x =  2
	std::string left = lhs->generate_code(os, ctx);
	std::string source_register = rhs->generate_code(os, ctx,code_gen::flags::ALLOCATE_VAR_IN_REG);
	std::string reg2;

	try {
        size_t pos;
        bool _ = std::stoi(left, &pos);  
		switch (type) {
		// x += 2;
		case ASSIGNMENT_TYPE::P:
			reg2 = lhs->generate_code(os, ctx, code_gen::flags::ALLOCATE_VAR_IN_REG);
			os << "\tadd " << reg2 << "," << reg2 << "," << source_register << "\n";
			ctx.free_register(source_register);
			source_register = reg2;
			break;
		case ASSIGNMENT_TYPE::M:
			reg2 = lhs->generate_code(os, ctx, code_gen::flags::ALLOCATE_VAR_IN_REG);
			os << "\tsub " << reg2 << "," << reg2 << source_register << "\n";
			ctx.free_register(source_register);
			source_register = reg2;
			break;
		default:
			break;
		}
		os << "\tsw " << source_register << "," << left << "(s0)\n";
	} catch (...) {
		os << "\tsw " << source_register << ',' <<  0  << "(" << left << ")\n";
		ctx.free_register(left);
	}
	ctx.free_register(source_register);
	return "";
}


void var_decl_statement_t::layout(code_gen::CodeGen_Context& ctx) const
{
	ctx.offset_counter += 4;
	ctx.add_var(name, { -ctx.offset_counter, type });
}

std::string var_decl_statement_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx,int32_t flags) const
{
	if (rhs == nullptr) return "";

	code_gen::var_info_t var_info = ctx.get_var_info(name);
	std::string source_register = rhs->generate_code(os,ctx,code_gen::flags::ALLOCATE_VAR_IN_REG);
	// get the actual offset based on the saved register and total_frame size
	os << "\tsw " << source_register << "," << actual_offset(ctx.frame_size,var_info.offset) << "(s0)\n";
	ctx.free_register(source_register);
	return "";
}


void block_statement_t::layout(code_gen::CodeGen_Context& ctx) const
{
	ctx.create_scope();
	for (auto& statement : statements) {
		statement->layout(ctx);
	}
}

std::string block_statement_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const
{
	ctx.push_scope();
	for (auto& statement : statements) {
		statement->generate_code(os, ctx,flags);
	}
	ctx.pop_scope();
	return "";
}


void if_statement_t::layout(code_gen::CodeGen_Context& ctx) const
{
	if (body) body->layout(ctx);
	if (else_body) else_body->layout(ctx);
}

std::string if_statement_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const
{

	if(body){
		std::string label1 = ctx.create_label();
		condition.back()->generate_code(os, ctx, code_gen::flags::IF_CONDITIONAL_EXPR);
		os <<',' << label1 << "\n";
		if (body->statements.empty()) {
			os << "\tnop\n";
		}
		else {
			body->generate_code(os, ctx,flags);
		}
		if(else_body){
			std::string label2 = ctx.create_label();
			os << "\tj " << label2 << "\n";
			os << label1 << ":\n";
			else_body->generate_code(os, ctx,flags);
			os << label2 << ":\n";
			return "";
		}
		os << label1 << ":\n";
	}
	return "";
}


void for_statement_t::layout(code_gen::CodeGen_Context& ctx) const
{
	if (body) body->layout(ctx);
}



void break_statement_t::layout(code_gen::CodeGen_Context& ctx) const
{
}

std::string break_statement_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const
{

	std::string label = ctx.create_label();
	os << "\tj " << label << "\n";
	ctx.break_jump_labels.push_back(label);
	return "";
}


void skip_statement_t::layout(code_gen::CodeGen_Context& ctx) const
{

}

std::string skip_statement_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags ) const
{

	//@Uncomplete : Handle error
	if (HAS_FLAG(flags, code_gen::flags::FOR_CONTROL_KEYWORD)) {

		std::string label = ctx.create_label();
		os << "\tj " << label << "\n";
		ctx.skip_jump_labels.push_back(label);
	}
	else if (HAS_FLAG(flags, code_gen::flags::WHILE_CONTROL_KEYWORD)) {

		os << "\tj " << ctx.skip_jump_labels.back() << "\n";
		ctx.skip_jump_labels.pop_back();
	}
	return "";
}


void expr_statement_t::layout(code_gen::CodeGen_Context& ctx) const
{

}

std::string expr_statement_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const
{
	if(expr) expr->generate_code(os, ctx);
	return "";
}

void func_decl_t::layout(code_gen::CodeGen_Context& ctx) const
{

	std::vector<code_gen::var_info_t> arg_params;
	ctx.offset_counter += 8;
	for (uint32_t i = 0; i <arguments.size();i++) {
		ctx.offset_counter += 4;
		arg_params.push_back({-ctx.offset_counter, arguments[i].type.base});
		ctx.add_var(arguments[i].name, { -ctx.offset_counter,arguments[i].type });
	}
	ctx.add_func_decl(id, { arg_params, return_type });
	body->layout(ctx);
}

std::string while_statement_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const
{
	std::string label1 = ctx.create_label();
	ctx.skip_jump_labels.push_back(label1);
	std::string label2 = ctx.create_label();
	os << "\tj " << label1 << '\n';
	os << label2 << ":\n";
	body->generate_code(os, ctx,code_gen::flags::WHILE_CONTROL_KEYWORD);
	os << label1 << ":\n";
	condition.back()->generate_code(os, ctx, code_gen::flags::WHILE_CONTROL_KEYWORD);
	os << "," << label2 << "\n"; // completes condition->generate_code()

	if (!ctx.break_jump_labels.empty()) {
		os << ctx.break_jump_labels.back() << ":\n";
		ctx.break_jump_labels.pop_back();
	}
	return "";
}

void return_statement_t::layout(code_gen::CodeGen_Context& ctx) const
{

}

std::string return_statement_t::generate_code(std::ostream& os, code_gen::CodeGen_Context& ctx, int32_t flags) const
{
	std::string reg = return_expr->generate_code(os,ctx,code_gen::flags::ALLOCATE_VAR_IN_REG);
	os << "\tmv a0," << reg << "\n";
	std::string label;
	if (ctx.return_jump_labels.empty()) {

		label = ctx.create_label();
	}
	else {
		label = ctx.return_jump_labels.back();
	}
	os << "\tj " << label << '\n';
	ctx.return_jump_labels.push_back(std::move(label));
	ctx.free_register(reg);
	return "";
}





















// AST PRINTING
void while_statement_t::print_ast(std::ostream& os, uint32_t indent_level /*= 0*/, bool is_last /*= true*/) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "while_statement" << COLOR_RESET << "\n";

	// Condition
	draw_branch(os, indent_level + 1, false);
	os << COLOR_LABEL << "condition" << COLOR_RESET << "\n";
	for (size_t i = 0; i < condition.size(); i++) {
		condition[i]->print_ast(os, indent_level + 2, i == condition.size() - 1);
	}

	// Body
	draw_branch(os, indent_level + 1, true);
	os << COLOR_LABEL << "body" << COLOR_RESET << "\n";
	if (body) body->print_ast(os, indent_level + 2);
}

void return_statement_t::print_ast(std::ostream& os, uint32_t indent_level /*= 0*/, bool is_last /*= true*/) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "return_statement" << COLOR_RESET << "\n";

	// Print the expression being returned (if any)
	if (return_expr) {
		draw_branch(os, indent_level + 1, true);
		os << COLOR_LABEL << "value" << COLOR_RESET << "\n";
		return_expr->print_ast(os, indent_level + 2, true);
	}
}

void func_decl_t::print_ast(std::ostream& os, uint32_t indent_level /*= 0*/, bool is_last /*= true*/) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_FUNC << "func_decl" << COLOR_RESET << "\n";
	draw_branch(os, indent_level + 1, false);
	os << COLOR_LABEL << "name : " << COLOR_FUNC << id << COLOR_RESET << "\n";
	draw_branch(os, indent_level + 1, false);
	os << COLOR_LABEL << "return_type : " << COLOR_TYPE << return_type.str() << COLOR_RESET << "\n";
	draw_branch(os, indent_level + 1, arguments.empty() && !body);
	os << COLOR_LABEL << "arguments" << COLOR_RESET << "\n";
	for (size_t i = 0; i < arguments.size(); i++) {
		arguments[i].print_ast(os, indent_level + 2, i == arguments.size() - 1 && !body);
	}
	if (body) {
		draw_branch(os, indent_level + 1, true);
		os << COLOR_LABEL << "body" << COLOR_RESET << "\n";
		body->print_ast(os, indent_level + 2);
	}
}

void expr_statement_t::print_ast(std::ostream& os, uint32_t indent_level /*= 0*/, bool is_last /*= true*/) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "expr_statement" << COLOR_RESET << "\n";
	if (expr) {
		expr->print_ast(os, indent_level + 1, true);
	}
}
void skip_statement_t::print_ast(std::ostream& os, uint32_t indent_level /*= 0*/, bool is_last /*= true*/) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "skip_statement" << COLOR_RESET << "\n";
}
void integer_literal_t::print_ast(std::ostream& os, uint32_t indent_level, bool is_last) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "integer : " << COLOR_LIT << value << COLOR_RESET << "\n";
}
void var_expression_t::print_ast(std::ostream& os, uint32_t indent_level, bool is_last) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "variable : " << COLOR_VAR << name << COLOR_RESET << "\n";
}
void func_call_expr_t::print_ast(std::ostream& os, uint32_t indent_level /*= 0*/, bool is_last /*= true*/) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "func_call" << COLOR_RESET << "\n";

	// Function name
	draw_branch(os, indent_level + 1, false);
	os << COLOR_LABEL << "name : " << COLOR_FUNC << id << COLOR_RESET << "\n";

	// Arguments
	draw_branch(os, indent_level + 1, arguments.empty());
	os << COLOR_LABEL << "arguments" << COLOR_RESET << "\n";

	for (size_t i = 0; i < arguments.size(); i++) {
		arguments[i]->print_ast(os, indent_level + 2, i == arguments.size() - 1);
	}
}
void binary_expression_t::print_ast(std::ostream& os, uint32_t indent_level, bool is_last) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "binary_op : " << COLOR_OP << bin_op_to_string(op) << COLOR_RESET << "\n";
	if (lhs) lhs->print_ast(os, indent_level + 1, false);
	if (rhs) rhs->print_ast(os, indent_level + 1, true);
}

void unary_expression_t::print_ast(std::ostream& os, uint32_t indent_level, bool is_last) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "unary_op : " << COLOR_OP << unary_op_to_string(op) << COLOR_RESET << "\n";
	if (expr) expr->print_ast(os, indent_level + 1, false);
}
void for_range_expression_t::print_ast(std::ostream& os, uint32_t indent_level /* = 0 */, bool is_last /* = true */) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "for_range_expression" << COLOR_RESET;

	// Exclusive / inclusive info
	os << " (" << (is_exclusive ? "exclusive" : "inclusive") << ")";
	os << "\n";

	// Start expression
	draw_branch(os, indent_level + 1, false);
	os << COLOR_LABEL << "start" << COLOR_RESET << "\n";
	if (start)
		start->print_ast(os, indent_level + 2, true);

	// Destination expression
	draw_branch(os, indent_level + 1, true);
	os << COLOR_LABEL << "destination" << COLOR_RESET << "\n";
	if (destination)
		destination->print_ast(os, indent_level + 2, true);
}

void assignment_expression_t::print_ast(std::ostream& os, uint32_t indent_level, bool is_last) const
{
	draw_branch(os, indent_level, is_last);
	switch (type) {

	case ASSIGNMENT_TYPE::P:
		os << COLOR_LABEL << "p_assignment(+=)" << COLOR_RESET << "\n";
		break;
	case ASSIGNMENT_TYPE::M:
		os << COLOR_LABEL << "m_assignment(-=)" << COLOR_RESET << "\n";
		break;
	default:
		os << COLOR_LABEL << "assignment(=)" << COLOR_RESET << "\n";
	}
	if (lhs) lhs->print_ast(os, indent_level + 1, false);
	if (rhs) rhs->print_ast(os, indent_level + 1, true);
}
void var_decl_statement_t::print_ast(std::ostream& os, uint32_t indent_level, bool is_last) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "variable_decl : " << COLOR_RESET
		<< COLOR_TYPE << type.str() << COLOR_RESET
		<< " " << COLOR_VAR << name << COLOR_RESET << "\n";
	if (rhs) {
		rhs->print_ast(os, indent_level + 1, true);
	}
}
void block_statement_t::print_ast(std::ostream& os, uint32_t indent_level, bool is_last /*= true*/) const
{
	for (size_t i = 0; i < statements.size(); i++) {
		// For each child statement, indent one level deeper
		// Pass 'true' for is_last only if this is the last child
		statements[i]->print_ast(os, indent_level + 1, i == statements.size() - 1);
	}
}
void if_statement_t::print_ast(std::ostream& os, uint32_t indent_level /*= 0*/, bool is_last /*= true*/) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "if_statement" << COLOR_RESET << "\n";

	draw_branch(os, indent_level + 1, false);
	os << COLOR_LABEL << "condition" << COLOR_RESET << "\n";
	for (size_t i = 0; i < condition.size(); i++) {
		condition[i]->print_ast(os, indent_level + 2, i == condition.size() - 1);
	}

	draw_branch(os, indent_level + 1, !else_body);
	os << COLOR_LABEL << "then" << COLOR_RESET << "\n";
	if (body) body->print_ast(os, indent_level + 2);

	if (else_body) {
		draw_branch(os, indent_level + 1, true);
		os << COLOR_LABEL << "else" << COLOR_RESET << "\n";
		else_body->print_ast(os, indent_level + 2);
	}
}
void break_statement_t::print_ast(std::ostream& os, uint32_t indent_level /*= 0*/, bool is_last /*= true*/) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "break_statement" << COLOR_RESET << "\n";
}
void for_statement_t::print_ast(std::ostream& os, uint32_t indent_level /*= 0*/, bool is_last /*= true*/) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "for_statement" << COLOR_RESET << "\n";

	// Range expression
	draw_branch(os, indent_level + 1, false);
	os << COLOR_LABEL << "range" << COLOR_RESET << "\n";
	if (range)
		range->print_ast(os, indent_level + 2, true);

	// Step expression
	draw_branch(os, indent_level + 1, false);
	os << COLOR_LABEL << "step" << COLOR_RESET << "\n";
	if (step)
		step->print_ast(os, indent_level + 2, true);

	// Body block
	draw_branch(os, indent_level + 1, true);
	os << COLOR_LABEL << "body" << COLOR_RESET << "\n";
	if (body)
		body->print_ast(os, indent_level + 2, true);
}

void f3_compiler::ast_node::func_decl_param_t::print_ast(std::ostream& os, uint32_t indent_level /*= 0*/, bool is_last /*= true*/) const
{
	draw_branch(os, indent_level, is_last);
	os << COLOR_LABEL << "param : " << COLOR_RESET
		<< COLOR_TYPE << type.str() << COLOR_RESET
		<< " " << COLOR_VAR << name << COLOR_RESET << "\n";
}
